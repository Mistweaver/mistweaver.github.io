{"componentChunkName":"component---src-templates-blurb-page-js","path":"/blurbs/the-dumbest-bug-sofar/","result":{"data":{"markdownRemark":{"html":"<p>The following is an account of the stupidest bug I have encountered in the last few years.  It is fact that I will in my career find dumber, but this one takes the cake so far.  Not to mention it's cause was due to the dumbest piece of code I ever had to write in my life.  So far...</p>\n<p><em>Edit 2/17/2021 - at some point I will post this abomination to Github.  I need to decouple it from it's parent application first</em></p>\n<p>Quick summary: my company wants the new interface for editing the sales inventory to look like excel and function like excel.  There's no negotiating this requirement, and I had three days to pull it off.  And it worked...kinda.  It made the database cry and the client was prone to memory crashes, but it actually worked in an elegantly twisted manner.</p>\n<p>That is, until 8/25/2020 where one of our users kept encountering a repeated error that made no sense by my understanding of how the code worked:</p>\n<pre><code>L10 is undefined \n</code></pre>\n<p>Some quick background: the price sheet editor mimics Excel in a lot of ways but much less efficiently. Each cell in the sheet is assigned a row index and a column index. So, the cell F4 is represented as an object below:</p>\n<pre><code>cell: { rowIndex: 3, columnIndex: 5 } \n</code></pre>\n<p>Since the price sheets are zero-indexed, it means A = 0, and row 1 has a row index of 0.  These keys are necessary so the user can make equations for complex calculations and values that are not only user-readable, but the application can interpret them as well.  If we merely used the indexes of the cells, an equation of</p>\n<pre><code>=A1 + B3 \n</code></pre>\n<p>would look like</p>\n<pre><code>= 00 + 24 \n</code></pre>\n<p>which would not only be unreadable, but the computer would interpret it as a value of 24.  Equations also have the SUM() capability like so:</p>\n<pre><code>=SUM(A3:P3) \n</code></pre>\n<p>The computer sees the 'SUM' as a marker in the string, reads the two keys (A3, P3) inside the string using the : as a delimiter and then iterates through each cell between A3 and P3 to sum all their subsequent values.  This is important as the existence of this functionality is what hid this code error for the last 6 months.  For now, let's go back to the original problem at hand and the equation that was the guilty party for bringing this issue to light.</p>\n<p><em>If at any point so far or moving forward you think \"This is terribly inefficient data design and could be done much better\", you would be correct.  I wrote this in three days with no assistance.  It is by far the worst code I've written.</em></p>\n<p>Now for the offending equation:</p>\n<pre><code>=(F10+I10+J10+K10+L10)*0.11 \n</code></pre>\n<p>The full error:</p>\n<pre><code>react-dom.production.min.js:52 Uncaught ReferenceError: L10 is not defined \r\nat eval (eval at CalculateSumBetweenIndexes (CalculateSumBetweenIndexes.tsx:32), &#x3C;anonymous>:1:15) \r\nat CalculateSumBetweenIndexes (CalculateSumBetweenIndexes.tsx:32) \r\nat FindAndReplaceSums.tsx:26 \r\nat s (FindKeysInEquationString.tsx:11) \r\nat Sheet.tsx:483 \r\nat Array.forEach (&#x3C;anonymous>) \r\nat Sheet.tsx:477 \r\nat Array.forEach (&#x3C;anonymous>) \r\nat Sheet.recalculateAllCells (Sheet.tsx:476) \r\nat Sheet.value (Sheet.tsx:165) \n</code></pre>\n<p>This error was thrown when the application would replace all the keys in an equation and then run the native JavaScript function eval() to calculate the value of the equation for the display value on the sheet.  In normal operations, an equation such as</p>\n<pre><code>= (F9+I9+J9+K9+L9)*0.11 \n</code></pre>\n<p>would be translated to</p>\n<pre><code>= (29995+1186+0+25+420)*0.11 \n</code></pre>\n<p>where the keys would be replaced with the values of their respective cells and could be evaluated correctly.  However, debugging the application show that, when the guilty string reached the eval() block, it would read</p>\n<pre><code>= (30711+1186+0+25+L10)*0.11 \n</code></pre>\n<p>The application did not convert L10 to its value, thus the eval() could not interpret the L10, throwing the Uncaught ReferenceError and crashing the whole application.  As we were going to retire this piece of the application soon, we tried a few workarounds that also failed.  If we skipped a row, the application would just throw the ReferenceError at L11.  If we skipped a column, the application would just throw the error at M10. Is it possible there were special characters in the object that were causing the issue as well?  Inspection of the database showed the object to be just fine:</p>\n<pre><code>{ \r\n    rowIndex: 10 \r\n    columnIndex: 11 \r\n    value: \"=(F10+I10+J10+K10+L10)*0.11\" \r\n    displayValue:\"\" \r\n    toolTip:\"\" \r\n    textColor:\"\" \r\n    backgroundColor:\"\" \r\n    formatType:\"currency\" \r\n    roundingPosition:2 \r\n} \n</code></pre>\n<p>No special characters, and it wouldn't matter anyway as the drag column feature would generate the strings from the application, ensuring they are clean, and the cell formatter would strip any extra characters that didn't match the criteria.  The special character theory is also ruled out when the row is deleted, as the error will just continue to L11, L12, etc. until all the digits beyond L10 are deleted.  Also during this process, we learned this error was occurring sporadically on other price sheets as well.  So it's not isolated and the only commonality between them was the state (Florida), which has absolutely no bearing on the calculations as the data is location agnostic (however, human input was not...)</p>\n<p>So, at this point we've established:</p>\n<ol>\n<li>The application crashes due to a key not being translated.</li>\n<li>The error seems to be focused on column L (meaning the equations in that column are part of the problem)</li>\n<li>The error only occurs with a row value beyond 9 (as L9 works in the test case)</li>\n<li>Only occurs on certain Florida price sheets</li>\n</ol>\n<p>If you are thinking this sounds like an array-out-of-bounds index, you are somewhat on the right path.  Next I followed the stack trace to the next offending function.  Line 32 of CalculateSumBetweenIndexes.tsx has the following code:</p>\n<pre><code>cellValue = eval(FindKeysInEquationString(table.rows[cell1.rowIndex].cells[i].value.substring(1), table)); \n</code></pre>\n<p>So the function that is failing is the FindKeysInEquationString().  FindKeysInEquationString.tsx calls two functions, FindAndReplaceSums() and FindAndReplaceKeys().  Debug shows the string clears the FindAndReplaceSums() normally (there was no SUM() function in the string so this is appropriate behavior) however after the FindAndReplaceKeys() function still returned the untranslated L10 value, so the guilty code resided there.</p>\n<p>FindAndReplaceKeys() is a simple function:</p>\n<pre><code>export function FindAndReplaceKeys(cellValue: string, table: Sheet) { \r\n    let newCellValue = cellValue; \r\n    let keyString = /[A-Z]+[0-9]+/; \r\n    let m; \r\n    do { \r\n        m = keyString.exec(newCellValue); \r\n        if(m) { \r\n            newCellValue = newCellValue.replace(m[0], SwapKeyForValue(m[0], table)); \r\n        } \r\n    } while (m); \r\n    return newCellValue; \r\n} \n</code></pre>\n<p>A simple explanation of this function: a string value and the table are passed to the function.  A keyString variable is created with the RegExp of '/[A-Z]+[0-9]+/g'. The function performs a Regex operation (.exec()) on the cell value, in this case the string '=(F10+I10+J10+K10+L10)*0.11', replaces the key value with its root numerical value, and then repeats itself until there are no more key matches in the string (or m = false).  Debugging this code reveals the problem:</p>\n<pre><code>FindAndReplaceKeys.tsx:7 FIND AND REPLACE KEYS IN STRING: (F10+I10+J10+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:12 /[A-Z]+[0-9]+/g \r\nFindAndReplaceKeys.tsx:16 [\"F10\", index: 1, input: \"(F10+I10+J10+K10+L10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: F10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+I10+J10+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+I10+J10+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:16 [\"I10\", index: 7, input: \"(30711+I10+J10+K10+L10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: I10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+J10+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+1186+J10+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:16 [\"J10\", index: 12, input: \"(30711+1186+J10+K10+L10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: J10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+0+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+1186+0+K10+L10)*0.11 \r\nFindAndReplaceKeys.tsx:16 [\"K10\", index: 12, input: \"(30711+1186+0+K10+L10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: K10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+0+25+L10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+1186+0+25+L10)*0.11 \r\nFindAndReplaceKeys.tsx:16 null \r\nFindAndReplaceKeys.tsx:24 NEW CELL VALUE: (30711+1186+0+25+L10)*0.11 \r\nFindAndReplaceKeys.tsx:25 \n</code></pre>\n<p>Apparently, the Regex just isn't recognizing the L10 pattern as a valid key, but all other patterns are matching.  Was the regex incorrect?  According to no less than 3 online regex testers, my regex string was correct and always yielded a match on L10, so why wasn't my application finding the string?  If we removed L10, the debug just showed this:</p>\n<pre><code>FindAndReplaceKeys.tsx:7 FIND AND REPLACE KEYS IN STRING: (F10+I10+J10+K10)*0.11 \r\nFindAndReplaceKeys.tsx:12 /[A-Z]+[0-9]+/g \r\nFindAndReplaceKeys.tsx:16 [\"F10\", index: 1, input: \"(F10+I10+J10+K10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: F10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+I10+J10+K10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+I10+J10+K10)*0.11 \r\nFindAndReplaceKeys.tsx:16 [\"I10\", index: 7, input: \"(30711+I10+J10+K10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: I10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+J10+K10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+1186+J10+K10)*0.11 \r\nFindAndReplaceKeys.tsx:16 [\"J10\", index: 12, input: \"(30711+1186+J10+K10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 Key found: J10 \r\nFindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+0+K10)*0.11 \r\nFindAndReplaceKeys.tsx:21 (30711+1186+0+K10)*0.11 \r\nFindAndReplaceKeys.tsx:16 null \r\nFindAndReplaceKeys.tsx:24 NEW CELL VALUE: (30711+1186+0+K10)*0.11 \r\nFindAndReplaceKeys.tsx:25 \n</code></pre>\n<p>Now K10 isn't being found. I have another function in this application that just returns an array of all the keys in a string, or FindKeys().  I place it before the previous function and lo and behold, it reveals:</p>\n<pre><code>Finding keys: (F10+I10+J10+K10)*0.11 \r\nFindKeys.tsx:14 Returning key list \r\nFindKeys.tsx:15 (4) [\"F10\", \"I10\", \"J10\", \"K10\"] \n</code></pre>\n<p>So, it finds the keys, but my other function won't?  I drop this test case in front of the loop:</p>\n<pre><code>let n = keyString.exec(\"(30711+1186+0+K10)*0.11\"); \n</code></pre>\n<p>And the output...</p>\n<pre><code>FindAndReplaceKeys.tsx:7 FIND AND REPLACE KEYS IN STRING: F1*0.03 \r\nFindAndReplaceKeys.tsx:12 /[A-Z]+[0-9]+/g \r\nFindAndReplaceKeys.tsx:14 ERROR CASE DEBUG \r\nFindAndReplaceKeys.tsx:15 [\"K10\", index: 14, input: \"(30711+1186+0+K10)*0.11\", groups: undefined] \r\nFindAndReplaceKeys.tsx:18 New cell value before keystring.exec \r\nFindAndReplaceKeys.tsx:19 F1*0.03 \r\nFindAndReplaceKeys.tsx:20 Keystring before keyString.exec \r\nFindAndReplaceKeys.tsx:21 /[A-Z]+[0-9]+/g \r\nFindAndReplaceKeys.tsx:23 null \r\nFindAndReplaceKeys.tsx:24 F1*0.03 \r\nFindAndReplaceKeys.tsx:32 NEW CELL VALUE: F1*0.03 \r\nFindAndReplaceKeys.tsx:33 \n</code></pre>\n<p>So my debug works and it finds K10, but now it crashes on the very first execution and won't find F1.  I replace my code with a variation of FindKeys() that returns a list of keys, iterates through the list of keys and swaps them accordingly.  The code:</p>\n<pre><code>export function findKeys(cellValue: string) { \r\n    let keyList = []; \r\n    let keyString = /[A-Z]+[0-9]+/g; \r\n    let m; \r\n    do { \r\n        m = keyString.exec(cellValue); \r\n        if(m) { \r\n            keyList.push(m[0]); \r\n        } \r\n    } while (m); \r\n    let newString = cellValue.slice(0); \r\n    keyList.forEach(key => { \r\n        newString = newString.replace(key, SwapKeyForValue(key, table)); \r\n    }); \r\n    return newString; \r\n} \n</code></pre>\n<p>I run the application and it works.  No bugs, no errors.  What on earth is happening here?  Turns out it's a perfect combination of bad programming, the nuances of the JavaScript native library, and the perfect edge case that hadn't appeared until this week.  Let's go step-by-step through it.</p>\n<p>First, the bad programming.  My primary mistake was not breaking up my code into separate responsibilities.  I should have always utilized the FindKeys() method to first return a list of keys in the string, THEN updated the string accordingly to replace all the matched keys.  By putting my update code inside the do-while loop, I was modifying a string at the same time I was searching that string.  Why does that matter? Because of .exec()...</p>\n<p>RegExp.prototype.exec() documentation shows</p>\n<blockquote>\n<p><em>The exec() method executes a search for a match in a specified string. Returns a result array, or null.</em></p>\n</blockquote>\n<blockquote>\n<p><em>JavaScript RegExp objects are stateful when they have the global or sticky flags set (e.g. /foo/g or /foo/y). They store a lastIndex from the previous match. Using this internally, exec() can be used to iterate over multiple matches in a string of text (with capture groups), as opposed to getting just the matching strings with String.prototype.match().</em></p>\n</blockquote>\n<blockquote>\n<p><em>A newer function has been proposed to simplify matching multiple parts of a string (with capture groups): String.prototype.matchAll().</em></p>\n</blockquote>\n<p>Putting the /g flag gives the regex a lastIndex property, which tracks where to start looking for a match in each string. Calling .exec() advances this internal pointer in the regex, so when the subsequent .exec() is called, it begins looking for the match from this updated pointer, not the beginning of the string.  If the /g flag is removed, it will always try to start matching from the beginning of the string.</p>\n<p>The /g flag is used to perform a global match (find all matches rather than stopping after the first match), which is why I defaulted to using it in my Regex expressions.</p>\n<p>Now why did this break the program, but only just now?  And why isn't this a consistent problem across all the price sheets?</p>\n<p>Let's look at the original string again:</p>\n<pre><code>=(F10+I10+J10+K10+L10)*0.11 \n</code></pre>\n<p>The values for each key are as follows:</p>\n<pre><code>F10: 30711 \r\nI10: 1186 \r\nJ10: 0 \r\nK10: 25 \r\nL10: 420 \n</code></pre>\n<p>See the 0 and the 25?  Until this week, these columns had always been added using the SUM() function, which just iterated between the boundary conditions and did not care about the cell keys, just the values in between the boundaries themselves.  However, this week our user changed their equation from SUM(F10:L10) to the equation above, so now the keys matter as they must each be found in the equation string and replaced.</p>\n<p>Normally these price sheets deal with double- or triple-digit values, which makes sense it's housing and it has large numbers.  However here we have thrown a wrench at the system.  That 0 value is a couple digits shorter than the usual prices.  Remember how the .exec() function keeps track of an internal pointer in the string as to where to begin its search again?  Let's go back to the debug of K10:</p>\n<pre><code>    FindAndReplaceKeys.tsx:7 FIND AND REPLACE KEYS IN STRING: (F10+I10+J10+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:12 /[A-Z]+[0-9]+/g \r\n    FindAndReplaceKeys.tsx:16 [\"F10\", index: 1, input: \"(F10+I10+J10+K10)*0.11\", groups: undefined] \r\n    FindAndReplaceKeys.tsx:18 Key found: F10 \r\n    FindAndReplaceKeys.tsx:20 Updated cell value: (30711+I10+J10+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:21 (30711+I10+J10+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:16 [\"I10\", index: 7, input: \"(30711+I10+J10+K10)*0.11\", groups: undefined] \r\n    FindAndReplaceKeys.tsx:18 Key found: I10 \r\n    FindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+J10+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:21 (30711+1186+J10+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:16 [\"J10\", index: 12, input: \"(30711+1186+J10+K10)*0.11\", groups: undefined] \r\n    FindAndReplaceKeys.tsx:18 Key found: J10 \r\n    FindAndReplaceKeys.tsx:20 Updated cell value: (30711+1186+0+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:21 (30711+1186+0+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:16 null \r\n    FindAndReplaceKeys.tsx:24 NEW CELL VALUE: (30711+1186+0+K10)*0.11 \r\n    FindAndReplaceKeys.tsx:25 \n</code></pre>\n<p>When we replace J10, we shorten the original string by 2 characters.</p>\n<pre><code>last index of RegEx object is now here, at 15 \r\n               v\r\n(30711+1186+J10+K10)*0.11 \n</code></pre>\n<p>So we start our search once again at the lastIndex + 1 of the Regex object, or 16, and that begins our search in the string here:</p>\n<pre><code>index 16 \r\n                v \r\n(30711+1186+0+K10)*0.11 \n</code></pre>\n<p>The Regex object begins at the new index, which with having shortened the string, now skips over the K value (as RegEx has no clue I am mutilating its object on the fly), and thus never finds K10.  Same thing occurs when L10 is present.</p>\n<p>But why now?  After 8 months of \"working\" why did this break now?  For this bug to happen, ALL of the below actions had to occur</p>\n<ol>\n<li>I had to be modifying the string within the Regex search loop</li>\n<li>I had to be using the Regex expression /[A-Z]+[0-9]+/g with the global tag, meaning it picks up where it leaves off</li>\n<li>Our user had to change formulas in the data</li>\n<li>The values of the new cells had to be shorter than the index losses from the Regex search.</li>\n</ol>\n<p>If even one of these triggers is modified, the bug would never occur and never be found.   This bug also explains why my debug pre-loop ruined the F1 key search, because the lastIndex property of the RegEx object had moved forward by 20 spots and never found the F1 in the subsequent string.</p>\n<p>Oof.</p>\n<p>Lessons:</p>\n<ol>\n<li>When using a function, actually know what it is doing.  Copy-paste code tends to get users into trouble when they don't understand the nuance.</li>\n<li>Limit my functions responsibilities.</li>\n<li>Use tests, and test for edge cases.  Proper testing would have revealed this bug sooner.</li>\n<li>Don't write production code in three days.</li>\n<li>Don't try to be Excel.</li>\n</ol>","frontmatter":{"title":"My dumbest bug (so far!)","summary":"The stupidest and most obnoxious bug I have fought. By no coincidence it also pairs with the dumbest piece of code I've written.","date":"04 February, 2021"}}},"pageContext":{"slug":"/blurbs/the-dumbest-bug-sofar/"}},"staticQueryHashes":[]}